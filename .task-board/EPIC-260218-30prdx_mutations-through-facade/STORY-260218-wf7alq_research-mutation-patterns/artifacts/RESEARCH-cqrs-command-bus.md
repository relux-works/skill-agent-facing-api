# Research: CQRS & Command Bus Patterns for CLI DSL Mutations

Date: 2026-02-18
Context: agentquery library — adding mutation/write support to the existing read-only DSL

---

## 1. Command Objects

### Structure

A command is a simple data container (like a DTO) describing an intent to change state. Canonical structure:

```go
// Domain-aligned naming, not CRUD
type ScheduleTraining struct {
    TrainingUUID string
    UserID       string
    StartDate    time.Time
    EndDate      time.Time
}

type CancelTraining struct {
    TrainingUUID string
    Reason       string
}
```

**Key properties:**
- **Name**: verb + noun, domain language. NOT "CreateX" / "UpdateX" / "DeleteX" — use domain terms like "Schedule", "Cancel", "Approve", "Reassign"
- **Payload**: only the data needed to execute the action. No ID generation inside — IDs are either provided or pre-generated by the caller
- **Immutable**: commands don't change after creation
- **No behavior**: pure data, no methods (unlike aggregates)

### How commands differ from queries

| Aspect | Query | Command |
|--------|-------|---------|
| Purpose | Read state | Change state |
| Returns | Data | Nothing (or minimal metadata: ID, status) |
| Side effects | None | Mutates state |
| Multiplicity | Many handlers ok | Exactly one handler per command |
| Idempotency | Naturally idempotent | May need explicit idempotency |
| Field projection | Yes (select fields) | No (fixed input schema) |

### Naming conventions (Three Dots Labs)

- "CreateTraining" -> "ScheduleTraining"
- "DeleteTraining" -> "CancelTraining"
- "UpdateNotes" -> "UpdateTrainingNotes"
- Follow how business stakeholders describe operations

### CLI DSL mapping

In the existing agentquery grammar `operation(params) { fields }`:
- Queries use `{ fields }` for projection
- Commands would use `(params)` for input, `{ fields }` is irrelevant (or could select return fields)
- Command names become the operation name: `schedule_training(uuid="abc", user="john")`

---

## 2. Command Handlers

### Registration patterns

**Watermill (Go) — generic handler constructor:**

```go
// NewCommandHandler infers command type from the function signature
err = commandProcessor.AddHandlers(
    cqrs.NewCommandHandler("BookRoomHandler", BookRoomHandler{eventBus}.Handle),
    cqrs.NewCommandHandler("OrderBeerHandler", OrderBeerHandler{eventBus}.Handle),
)
```

**go-commandbus — simple registration:**

```go
bus := commandbus.New()
bus.Register(&CreateUser{}, CreateHandler)
bus.Execute(context.Background(), &CreateUser{"name"})
```

**Go-MediatR — type-parameterized registration:**

```go
mediatr.RegisterHandler[*CreateProductCommand, *CreateProductCommandResponse](
    createProductCommandHandler,
)

// Sending
response, err := mediatr.Send[*CreateProductCommand, *CreateProductCommandResponse](ctx, command)
```

**Generic mediator pattern (pkritiotis/go-mediator):**

```go
type RequestHandler[TRequest any, TResult any] interface {
    Handle(request TRequest) (TResult, error)
}

func Register[TRequest any, TResult any](handler RequestHandler[TRequest, TResult]) error {
    var k key[TRequest, TResult]
    _, existed := registeredHandlers.LoadOrStore(reflect.TypeOf(k), handler)
    if existed {
        return errors.New("already registered")
    }
    return nil
}

func Send[TRequest any, TResult any](r TRequest) (TResult, error) {
    var k key[TRequest, TResult]
    handler, ok := registeredHandlers.Load(reflect.TypeOf(k))
    if !ok {
        return zeroRes, errors.New("handler not found")
    }
    return handler.Handle(r)
}
```

### Constraint: one command = one handler

All CQRS implementations enforce this. Unlike events/queries which can have multiple handlers, a command maps to exactly one handler. Adding a duplicate handler returns an error.

### Handler signature patterns

```go
// Pattern 1: error only (pure CQRS)
func Handle(ctx context.Context, cmd *BookRoom) error

// Pattern 2: result + error (pragmatic CQRS)
func Handle(ctx context.Context, cmd *CreateProduct) (*CreateProductResponse, error)

// Pattern 3: any + error (agentquery-compatible, JSON-serializable)
func Handle(ctx context.Context, cmd CommandContext) (any, error)
```

### CLI DSL mapping

The existing `OperationHandler[T]` signature already works:
```go
type OperationHandler[T any] func(ctx OperationContext[T]) (any, error)
```

A mutation handler would have a similar shape but with different context:
```go
type MutationHandler[T any] func(ctx MutationContext[T]) (any, error)

type MutationContext[T any] struct {
    Command   string            // mutation name
    Args      map[string]string // parsed key=value params
    RawArgs   []Arg             // from AST
    // No Items loader — mutations don't need the full dataset
    // No Selector — no field projection for mutations
}
```

---

## 3. Command Discovery / Registry / Schema Introspection

### The problem

Agents need to discover: what mutations are available, what parameters each accepts, what each does. This is exactly the same problem as `schema()` for read operations.

### Watermill approach

Watermill uses Go's type system — commands are Go structs, discovery is implicit via code. No runtime introspection. The command name is derived from the struct name:

```go
func FullyQualifiedStructName(v interface{}) string  // "events.UserCreated"
func StructName(v interface{}) string                 // "UserCreated"
```

### agentquery approach (already exists for reads)

The existing `schema()` operation returns:
```json
{
  "operations": ["get", "list", "count", "schema"],
  "fields": ["id", "name", "status"],
  "presets": {"overview": ["id", "name"]},
  "operationMetadata": {
    "list": {
      "description": "List items with filtering",
      "parameters": [{"name": "status", "type": "string", "optional": true}],
      "examples": ["list(status=done) { overview }"]
    }
  },
  "filterableFields": ["status"],
  "sortableFields": ["name", "priority"]
}
```

**For mutations, extend this with:**
```json
{
  "mutations": ["create", "update_status", "delete"],
  "mutationMetadata": {
    "create": {
      "description": "Create a new task",
      "parameters": [
        {"name": "name", "type": "string", "optional": false},
        {"name": "status", "type": "string", "optional": true, "default": "todo"}
      ],
      "examples": ["create(name=\"Fix bug\", status=todo)"]
    }
  }
}
```

### Key design choice: keep mutations separate from operations in introspection

An agent asking `schema()` should clearly see which things are reads vs writes. Mixing them in `"operations"` loses this signal.

---

## 4. Validation

### Three-layer validation model (Daniel Whittaker / Enterprise Craftsmanship)

**Layer 1: Structural/Syntactic validation** (pre-handler)
- Required fields present
- Types correct (string, int, bool)
- Format valid (email, UUID)
- This is the "have I filled out the form correctly" layer
- Can be fully automated from parameter metadata

**Layer 2: Domain/Business rule validation** (in-handler or in-aggregate)
- "Can I affect this change given the current system state?"
- Example: "Can this training be cancelled? Is it in a cancellable state?"
- Requires loading the entity, checking invariants
- Belongs in the domain layer, NOT in a generic middleware

**Layer 3: Infrastructure validation** (in-handler)
- External service availability
- Database constraints
- Race conditions

### Validation decorator pattern

```go
// Middleware chain: validate -> log -> handle
type ValidationMiddleware struct {
    validators map[string]func(args map[string]string) error
}

func (v *ValidationMiddleware) Handle(ctx context.Context, cmd any, next HandlerFunc) (any, error) {
    if err := v.validate(cmd); err != nil {
        return nil, &ValidationError{Errors: err}
    }
    return next(ctx, cmd)
}
```

### Go-MediatR PipelineBehavior

```go
type PipelineBehavior interface {
    Handle(ctx context.Context, request interface{}, next RequestHandlerFunc) (interface{}, error)
}

// Registration
loggerPipeline := &RequestLoggerBehaviour{}
mediatr.RegisterRequestPipelineBehaviors(loggerPipeline)
```

### CLI DSL mapping

For agentquery, structural validation can be auto-derived from `MutationMetadata`:

```go
type MutationMetadata struct {
    Description string         `json:"description,omitempty"`
    Parameters  []ParameterDef `json:"parameters,omitempty"` // reuse existing type
    Examples    []string       `json:"examples,omitempty"`
}
```

The framework validates:
1. Required parameters are present (from `ParameterDef.Optional == false`)
2. Unknown parameters are rejected (from registered parameter names)

The handler validates:
3. Domain rules (entity exists, state transition valid, etc.)

---

## 5. Error Handling

### Error categories (Enterprise Craftsmanship)

**Expected errors** (represent as values/Result types):
- Validation failures (missing field, bad format)
- Business rule violations (item not found, invalid state transition)
- These should be structured, serializable, and predictable

**Unexpected errors** (represent as exceptions/panics):
- Bugs, failed assumptions, infrastructure failures
- Generic "something went wrong" to the caller
- Log + surface generic error

### Existing agentquery error types (already well-suited)

```go
const (
    ErrParse      = "PARSE_ERROR"       // syntax errors
    ErrNotFound   = "NOT_FOUND"         // item/operation not found
    ErrValidation = "VALIDATION_ERROR"  // input validation
    ErrInternal   = "INTERNAL_ERROR"    // infrastructure/bugs
)

type Error struct {
    Code    string         `json:"code"`
    Message string         `json:"message"`
    Details map[string]any `json:"details,omitempty"`
}
```

**For mutations, add:**

```go
const (
    ErrConflict   = "CONFLICT"          // concurrent modification, duplicate
    ErrForbidden  = "FORBIDDEN"         // authorization failure
    ErrPrecondition = "PRECONDITION_FAILED" // business rule violation
)
```

### Mutation-specific error patterns

```go
// Validation error — multiple fields can fail at once
return nil, &Error{
    Code:    ErrValidation,
    Message: "invalid input",
    Details: map[string]any{
        "errors": []map[string]string{
            {"field": "name", "message": "required"},
            {"field": "status", "message": "must be one of: todo, in_progress, done"},
        },
    },
}

// Business rule violation
return nil, &Error{
    Code:    ErrPrecondition,
    Message: "cannot delete task: has dependent tasks",
    Details: map[string]any{
        "task_id": "task-1",
        "dependent_tasks": []string{"task-2", "task-3"},
    },
}
```

---

## 6. Batching

### Read batching in agentquery (already works)

```
list(status=done) { overview }; count()
```
Each statement executes independently. Per-statement errors don't abort the batch.

### Mutation batching — key questions

**Option A: Independent execution (same as reads)**
Each mutation executes independently. If one fails, others still run.
```
create(name="Task A"); create(name="Task B"); update_status(id=task-1, status=done)
```
Simple, consistent with existing batch semantics.

**Option B: All-or-nothing (transactional)**
All mutations succeed or all are rolled back.
Problem: requires transaction support from the data layer. Not generic.

**Option C: Stop-on-error**
Execute sequentially, stop at first failure. Return partial results.

### Recommendation for agentquery: Option A (independent)

- Consistent with existing batch query semantics
- No framework-level transaction support needed
- Handlers can implement their own transactions internally
- Each result in the batch array includes success or error

### Saga pattern (for reference, probably overkill)

For complex multi-step mutations, the Saga pattern chains local transactions with compensating actions. Each step has a forward action and a compensating (rollback) action. If step N fails, steps N-1...1 are compensated.

```go
type Saga struct {
    Steps []SagaStep
}

type SagaStep struct {
    Name       string
    Action     func(ctx context.Context) error
    Compensate func(ctx context.Context) error
}
```

This is too heavy for a CLI DSL library. Handlers can implement this internally if needed.

---

## 7. Go Implementations Summary

### Watermill (ThreeDotsLabs)
- **Repo**: github.com/ThreeDotsLabs/watermill
- **Approach**: Pub/Sub based, message-oriented
- **Command handler**: Interface with `HandlerName()`, `NewCommand()`, `Handle(ctx, cmd)`
- **Registration**: `commandProcessor.AddHandlers(...)`
- **Middleware**: `OnHandle` callback in config
- **Constraint**: One handler per command (DuplicateCommandHandlerError)
- **Relevance**: Heavy — designed for distributed systems. The CommandHandler interface and OnHandle middleware pattern are useful references.

### Go-MediatR (mehdihadeli)
- **Repo**: github.com/mehdihadeli/Go-MediatR
- **Approach**: Mediator pattern, in-process
- **Command handler**: Generic `RequestHandler[TRequest, TResponse]` interface
- **Registration**: `mediatr.RegisterHandler[Cmd, Resp](handler)`
- **Pipeline**: `PipelineBehavior` with `Handle(ctx, request, next)` chain
- **Relevance**: Good reference for pipeline middleware pattern. Uses generics well.

### go-commandbus (lana)
- **Repo**: github.com/lana/go-commandbus
- **Approach**: Minimal command bus
- **Registration**: `bus.Register(&CreateUser{}, handler)`
- **Execution**: `bus.Execute(ctx, &CreateUser{...})`
- **Relevance**: Very minimal. Shows the core pattern without noise.

### go-mediator (pkritiotis)
- **Repo**: github.com/pkritiotis/go-mediator
- **Approach**: Generic mediator using Go 1.18+ generics
- **Registration**: `Register[TReq, TRes](handler)`
- **Dispatch**: `Send[TReq, TRes](request)`
- **Key insight**: Uses `reflect.TypeOf(key[TReq, TRes]{})` as map key for type-safe dispatch
- **Relevance**: Shows how to map generic types to handlers using reflection.

---

## 8. Design Implications for agentquery

### What to keep the same

1. **Same DSL grammar** — mutations use the same `operation(params)` syntax. No grammar changes.
2. **Same batch semantics** — semicolon-separated, independent execution, per-statement errors.
3. **Same error types** — extend with new codes, same `Error` struct.
4. **Same introspection pattern** — `schema()` returns mutations alongside operations.
5. **Same OutputMode** — JSON and compact format work for mutation results too.

### What's different from reads

1. **No field projection** — mutations don't return projected domain objects (or if they return data, it's a fixed response shape).
2. **No Items loader** — mutations don't need the full dataset. They receive input and produce a result.
3. **No Predicate** — filtering doesn't apply to mutations.
4. **Validation is mandatory** — structural validation from metadata should be enforced before the handler runs.
5. **Mutation metadata must distinguish required vs optional params** — agents need this to construct valid commands.

### Possible `Schema[T]` API extension

```go
// Registration
s.Mutation("create", createHandler)
s.MutationWithMetadata("create", createHandler, MutationMetadata{...})

// Handler type
type MutationHandler[T any] func(ctx MutationContext) (any, error)

type MutationContext struct {
    Mutation  string
    Args      []Arg
    ArgMap    map[string]string  // convenience: key=value pairs
}

// Execution — reuse Query() dispatch, but mutations are in a separate registry
s.Execute("create(name=\"Fix bug\")")       // returns (any, error)
s.ExecuteJSON("create(name=\"Fix bug\")")   // returns ([]byte, error)
```

### Open questions

1. Should mutations and queries share the same dispatch path (`Query()`) or have a separate `Execute()` method?
2. Should mutation results support field projection (like GraphQL mutations returning the mutated object)?
3. Should the parser distinguish mutations from queries syntactically, or is it just a registry difference?
4. How should dry-run / preview work? (e.g., `create(name="X", dry_run=true)`)
5. Should there be a `mutations()` introspection operation separate from `schema()`, or extend `schema()`?

---

## Sources

- [Watermill CQRS Component](https://watermill.io/docs/cqrs/)
- [Basic CQRS in Go — Three Dots Labs](https://threedots.tech/post/basic-cqrs-in-go/)
- [go-commandbus](https://github.com/lana/go-commandbus)
- [Go-MediatR](https://github.com/mehdihadeli/Go-MediatR)
- [go-mediator — Generic mediator in Go](https://pkritiotis.io/mediator-pattern-in-go/)
- [Watermill CQRS package types](https://pkg.go.dev/github.com/ThreeDotsLabs/watermill/components/cqrs)
- [Validating commands with the Decorator Pattern](https://codeopinion.com/validating-commands/)
- [CQRS and exception handling — Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/cqrs-exception-handling/)
- [Command Bus pattern](https://ducmanhphan.github.io/2020-12-02-command-bus-pattern/)
- [Can command return a value? — Event-Driven.io](https://event-driven.io/en/can_command_return_a_value/)
- [Returning from Command Buses — Ross Tuck](https://www.rosstuck.com/returning-from-command-buses)
- [Command naming — Three Dots Labs](https://threedots.tech/post/basic-cqrs-in-go/)
- [CQRS command validation — Daniel Whittaker](https://danielwhittaker.me/2016/04/20/how-to-validate-commands-in-a-cqrs-application/)
- [Validate commands in CQRS — Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/validate-commands-cqrs/)
